#!/usr/bin/perl

# Defaults here (currently hardcoded, move to config file later)

$modes_file = "/home/groups/oroaklab/src/unidex/modes.cfg";
$fastq_path = "/home/groups/oroaklab/fastq";
$dex_path = "/home/groups/oroaklab/demultiplex";
$def_hd = 2;
$gzip = "gzip";
$zcat = "zcat";

# Description here

$die = "

UNIDEX (Universal Demultiplexer, v0.210607-test1)

Usage:

unidex [options] 

Options:
  -R  [STR]   Run Folder (where fastq files are present)
  -M  [LIST]  Mode list - modes must be specified in the modes.cfg file ($modes_file)
              Modes must be comma separated and will demultiplex in specified order listed.

Default Options:
  -O  [STR]   Output folder (def = run name, -R)
  -d  [0,1,2] Hamming distance (max 2, def = $def_hd)

Default Locations:
  -r  [PATH]  Fastq folder full path (def = $fastq_path)
  -o  [PATH]  Output folder (def = $dex_path)
  -m  [STR]   Mode config file (def = $modes_file)
  
Fastq Input (default = auto detect):
  -A  [STR]   Read 1 fastq
  -B  [STR]   Read 2 fastq
  -C  [STR]   Index 1 fastq
  -D  [STR]   Index 2 fastq
  
Other Options:
  -S  [STR]   Subset of indexes for a mode.
                mode1:indexN:(comma separated list of index names);mode2...
                Index names must be the 1st column of an index file.
  -g  [STR]   Gzip command (def = $gzip)
  -z  [STR]   Zcat command (def = $zcat)
  -V          Verbose / debug mode (outputs to STDERR)


";

# load & parse options
use Getopt::Std; %opt = ();
getopts("R:M:O:r:o:m:A:B:C:D:d:VS:g:", \%opt);

if (!defined $opt{'R'}) {
	if (defined $opt{'A'} || defined $opt{'B'} || defined $opt{'C'} || defined $opt{'D'}) {
		if (!defined $opt{'O'}) {
			die "ERROR: When not supplying -R and instead specifying individual fastq files, an output name must be provided (-O).";
		}
	} else {
		die "$die\nERROR: If -R is not specified, each input fastq must be specified (min of 1)!";
	}
}
if (!defined $opt{'M'}) {
	die "$die\nERROR: Modes list must be specified with one or more modes!\n";
} else {
	@MODES_LIST = split(/,/, $opt{'M'});
	foreach $mode (@MODES_LIST) {$MODES{$mode} = 0};
}
if (defined $opt{'r'}) {$fastq_path = $opt{'r'}}; $fastq_path =~ s/\/$//;
if (defined $opt{'o'}) {$dex_path = $opt{'o'}}; $dex_path =~ s/\/$//;
if (defined $opt{'m'}) {$modes_file = $opt{'m'}};
if (!defined $opt{'O'}) {$opt{'O'} = $opt{'R'}};
$out_name = $opt{'O'}; $out_name =~ s/\/$//;
$run_name = $opt{'R'}; $run_name =~ s/\/$//;

if (defined $opt{'S'}) {
	@SUBSETS = split(/;/, $opt{'S'});
	foreach $subset (@SUBSETS) {
		($mode,$index_number,$index_list) = split(/:/, $subset);
		$index_number =~ s/index//i;
		@INDEX_LIST = split(/,/, $index_list);
		foreach $index_ID (@INDEX_LIST) {
			$SUBSETS{$mode}{$index_number}{$index_ID} = 1;
		}
	}
}

# identify input fastq files

if (!defined $opt{'A'}) {
	if (-e "$fastq_path/$run_name/Undetermined_S0_L001_R1_001.fastq.gz") {
		$read1_fastq = "$fastq_path/$run_name/Undetermined_S0_L001_R1_001.fastq.gz $fastq_path/$run_name/Undetermined_S0_L002_R1_001.fastq.gz $fastq_path/$run_name/Undetermined_S0_L003_R1_001.fastq.gz $fastq_path/$run_name/Undetermined_S0_L004_R1_001.fastq.gz";
		$read_used[1] = "true";
	} elsif (-e "$fastq_path/$run_name/Undetermined_S0_R1_001.fastq.gz") {
		$read1_fastq = "$fastq_path/$run_name/Undetermined_S0_R1_001.fastq.gz";
		$read_used[1] = "true";
	} else {
		$read1_fastq = "null"; $read_used[1] = "null";
	}
} else {$read1_fastq = "$opt{'A'}"}
if (defined $opt{'V'}) {print STDERR "INFO: read 1 fastq = $read1_fastq\n"};

if (!defined $opt{'B'}) {
	if (-e "$fastq_path/$run_name/Undetermined_S0_L001_R2_001.fastq.gz") {
		$read2_fastq = "$fastq_path/$run_name/Undetermined_S0_L001_R2_001.fastq.gz $fastq_path/$run_name/Undetermined_S0_L002_R2_001.fastq.gz $fastq_path/$run_name/Undetermined_S0_L003_R2_001.fastq.gz $fastq_path/$run_name/Undetermined_S0_L004_R2_001.fastq.gz";
		$read_used[4] = "true";
	} elsif (-e "$fastq_path/$run_name/Undetermined_S0_R2_001.fastq.gz") {
		$read2_fastq = "$fastq_path/$run_name/Undetermined_S0_R2_001.fastq.gz";
		$read_used[4] = "true";
	} else {
		$read2_fastq = "null"; $read_used[4] = "null";
	}
} else {$read2_fastq = "$opt{'B'}"}
if (defined $opt{'V'}) {print STDERR "INFO: read 2 fastq = $read2_fastq\n"};

if (!defined $opt{'C'}) {
	if (-e "$fastq_path/$run_name/Undetermined_S0_L001_I1_001.fastq.gz") {
		$index1_fastq = "$fastq_path/$run_name/Undetermined_S0_L001_I1_001.fastq.gz $fastq_path/$run_name/Undetermined_S0_L002_I1_001.fastq.gz $fastq_path/$run_name/Undetermined_S0_L003_I1_001.fastq.gz $fastq_path/$run_name/Undetermined_S0_L004_I1_001.fastq.gz";
		$read_used[2] = "true";
	} elsif (-e "$fastq_path/$run_name/Undetermined_S0_I1_001.fastq.gz") {
		$index1_fastq = "$fastq_path/$run_name/Undetermined_S0_I1_001.fastq.gz";
		$read_used[2] = "true";
	} else {
		$index1_fastq = "null"; $read_used[2] = "null";
	}
} else {$index1_fastq = "$opt{'C'}"}
if (defined $opt{'V'}) {print STDERR "INFO: index 1 fastq = $index1_fastq\n"};

if (!defined $opt{'D'}) {
	if (-e "$fastq_path/$run_name/Undetermined_S0_L001_I2_001.fastq.gz") {
		$index2_fastq = "$fastq_path/$run_name/Undetermined_S0_L001_I2_001.fastq.gz $fastq_path/$run_name/Undetermined_S0_L002_I2_001.fastq.gz $fastq_path/$run_name/Undetermined_S0_L003_I2_001.fastq.gz $fastq_path/$run_name/Undetermined_S0_L004_I2_001.fastq.gz";
		$read_used[3] = "true";
	} elsif (-e "$fastq_path/$run_name/Undetermined_S0_I2_001.fastq.gz") {
		$index2_fastq = "$fastq_path/$run_name/Undetermined_S0_I2_001.fastq.gz";
		$read_used[3] = "true";
	} else {
		$index2_fastq = "null"; $read_used[3] = "null";
	}
} else {$index2_fastq = "$opt{'D'}"}
if (defined $opt{'V'}) {print STDERR "INFO: index 2 fastq = $index2_fastq\n"};


# load modes
%DEX_PARTS = (); %MODE_ixCT = ();
open MODES, "$modes_file";
while ($l = <MODES>) {
	chomp $l;
	if ($1 =~ /^##/) {
		# comment lines
	} elsif ($l =~ /^#/) {
		@HEADER = split(/\t/, $l);
	} else {
		@P = split(/\t/, $l);
		$mode = $P[0];
		if (defined $MODES{$P[0]}) {
			if (defined $opt{'V'}) {print STDERR "INFO: Mode $P[0] found. Parsing...\n"};
			$MODES{$mode} = 1;
			# parse the four reads and store information on components
			%{$DEX_PARTS{$mode}} = ();
			%{$INDEX_FILES{$mode}} = ();
			for ($i = 1; $i <= 4; $i++) { # parse the four fastq reads
				if (defined $opt{'V'}) {print STDERR "INFO: parsing read $i: $P[$i]\n"};
				if ($P[$i] =~ /unused/i) {
					if (defined $opt{'V'}) {print STDERR "\t$HEADER[$i] is unused.\n"};
				} else {
					if ($i == 1 && $read1_fastq eq "null") {die "ERROR: mode $mode requires Read 1 and read 1 fastq could not be detected or was not specified!\n"};
					if ($i == 2 && $index1_fastq eq "null") {die "ERROR: mode $mode requires Index 1 and index 1 fastq could not be detected or was not specified!\n"};
					if ($i == 3 && $index2_fastq eq "null") {die "ERROR: mode $mode requires Index 1 and index 1 fastq could not be detected or was not specified!\n"};
					if ($i == 4 && $read2_fastq eq "null") {die "ERROR: mode $mode requires Read 2 and read 2 fastq could not be detected or was not specified!\n"};
					$pos = 0;
					@READ_PARTS = split(/,/, $P[$i]);
					for ($part = 0; $part < @READ_PARTS; $part++) {
						($part_name,$part_length) = split(/:/, $READ_PARTS[$part]);
						if (defined $opt{'V'}) {print STDERR "\tname = $part_name, length = $part_length\n"};
						if ($part_name =~ /read/i) {
							$read_number = $part_name; $read_number =~ s/read//i;
							if (!defined $DEX_PARTS{$mode}{'read'}{$read_number}) {
								@{$DEX_PARTS{$mode}{'read'}{$read_number}} = ($i,$pos,$part_length);
								$pos+=$part_length;
							} else {
								die "ERROR: Two instances of read - $read_number were specified in the mode configuration for $mode!\n";
							}
						} elsif ($part_name =~ /index/i) {
							if ($part_length < 1) {die "ERROR: Index lengths must be specified (ie cannot be '0' for rest of read), issue index: $mode, $part_name\n"};
							$index_number = $part_name; $index_number =~ s/index//i;
							$MODE_ixCT{$mode}++;
							if ($index_number =~ /=/) { # HD override found
								($number,$hd) = split(/=/, $index_number);
								$index_number = $number;
								$INDEX_HAMMING{$mode}{'index'}{$index_number} = $hd;
							} else {
								$INDEX_HAMMING{$mode}{'index'}{$index_number} = $def_hd;
							}
							if (defined $opt{'V'}) {print STDERR "INFO: mode $mode, index number $index_number hamming distance set to: $INDEX_HAMMING{$mode}{'index'}{$index_number}.\n"};
							if (!defined $DEX_PARTS{$mode}{'index'}{$index_number}) {
								if (defined $opt{'V'}) {print STDERR "INFO: mode $mode, index number $index_number being stored.\n"};
							@{$DEX_PARTS{$mode}{'index'}{$index_number}} = ($i,$pos,$part_length);
								$INDEX_FILES{$mode}{'index'}{$index_number} = "null";
								$pos+=$part_length;
							} else {
								die "ERROR: Two instances of index - $index_number were specified in the mode configuration for $mode!\n";
							}
						} elsif ($part_name =~ /null/i) {
							$pos+=$part_length;
						} else { # UMI / other component - will add as special field in read name
							if (!defined $DEX_PARTS{$mode}{'other'}{$part_name}) {
								@{$DEX_PARTS{$mode}{'other'}{$part_name}} = ($i,$pos,$part_length);
								$pos+=$part_length;
							} else {
								die "ERROR: Two instances of other - $part_name were specified in the mode configuration for $mode!\n";
							}
						}
					}
				}
			}
			
			# report stored components
			if (defined $opt{'V'}) {
				print STDERR "INFO: Mode $mode stored components:\n";
				foreach $class (keys %{$DEX_PARTS{$P[0]}}) {
					foreach $component (keys %{$DEX_PARTS{$P[0]}{$class}}) {
						print STDERR "\t$class\t$component = $DEX_PARTS{$P[0]}{$class}{$component}[0],$DEX_PARTS{$P[0]}{$class}{$component}[1],$DEX_PARTS{$P[0]}{$class}{$component}[2]\n";
					}
				}
			}
			
			# load index file locations
			for ($i = 5; $i < @P; $i++) {
				($index_name,$file) = split(/=/, $P[$i]);
				$index_number = $index_name; $index_number =~ s/index//i;
				if (defined $INDEX_FILES{$P[0]}{'index'}{$index_number}) {
					$INDEX_FILES{$P[0]}{'index'}{$index_number} = $file;
				} else {
					print STDERR "\tWARNING: Index $index_number for $P[0] mode has a file but no index component specified! Ignoring file.\n";
				}
			}
			
			# check all index files are specified
			foreach $index_number (keys %{$INDEX_FILES{$P[0]}{'index'}}) {
				if ($INDEX_FILES{$P[0]}{'index'}{$index_number} eq "null") {
					die "ERROR: Index $index_number for $P[0] mode has a component specified but no corresponding index file!\n";
				}
			}
		}
	}
} close MODES;
foreach $mode (@MODES_LIST) {
	if ($MODES{$mode} < 1) {
		die "ERROR: Mode $mode is listed but was not found in the modes config file: $modes_file!\n";
	}
}

# load index files & compute hamming distance

# hash of bases to swap out
%OTHER_BASES = ();
%{$OTHER_BASES{'A'}} = ("C" => "C", "G" => "G", "T" => "T", "N" => "N");
%{$OTHER_BASES{'C'}} = ("A" => "A", "G" => "G", "T" => "T", "N" => "N");
%{$OTHER_BASES{'G'}} = ("C" => "C", "A" => "A", "T" => "T", "N" => "N");
%{$OTHER_BASES{'T'}} = ("C" => "C", "G" => "G", "A" => "A", "N" => "N");

if (defined $opt{'V'}) {print STDERR "INFO: Generating hamming hashes ...\n"};

%MODE_IXN_CHECK_true = ();
foreach $mode (@MODES_LIST) {
	foreach $index_number (keys %{$INDEX_FILES{$mode}{'index'}}) {
		if (defined $opt{'V'}) {print STDERR "\tMode: $mode, Index: $index_number, File = $INDEX_FILES{$mode}{'index'}{$index_number}\n"};
		if (-e "$INDEX_FILES{$mode}{'index'}{$index_number}") {} else {die "ERROR: File: $INDEX_FILES{$mode}{'index'}{$index_number} does not exist!\n"};
		open IN, "$INDEX_FILES{$mode}{'index'}{$index_number}";
		while ($l = <IN>) {
			chomp $l;
			#if (defined $opt{'V'}) {print STDERR "\t\tInput line $l ... "};
			@P = split(/\t/, $l);
			if (defined $SUBSET{$mode}{$index_number}) {
				if (defined $SUBSET{$mode}{$index_number}{$P[0]}) {
					$MODE_IXN_CHECK_true{$mode}{$index_number}{$P[-1]} = $P[-1];
					#if (defined $opt{'V'}) {print STDERR "Index stored as: $MODE_IXN_CHECK_true{$mode}{$index_number}{$P[@P-1]}\n"};
				}
			} else {
				$MODE_IXN_CHECK_true{$mode}{$index_number}{$P[-1]} = $P[-1];
				#if (defined $opt{'V'}) {print STDERR "Index stored as: $MODE_IXN_CHECK_true{$mode}{$index_number}{$P[@P-1]}\n"};
			}
		} close IN;
		
		# make HD hash
		if ($INDEX_HAMMING{$mode}{'index'}{$index_number} > 0) {
			if (defined $opt{'V'}) {print STDERR "\t\tIndex $index_number HD = $INDEX_HAMMING{$mode}{'index'}{$index_number}, making HD hash.\n"};
			for ($hd_round = 1; $hd_round <= $INDEX_HAMMING{$mode}{'index'}{$index_number}; $hd_round++) {
				if (defined $opt{'V'}) {print STDERR "\t\t\tHD Round = $hd_round ...\n"};
				%HDSEQ_true = ();
				foreach $seq (keys %{$MODE_IXN_CHECK_true{$mode}{$index_number}}) {
					$true = $MODE_IXN_CHECK_true{$mode}{$index_number}{$seq};
					@SEQ = split(//, $seq);
					for ($ix_base = 0; $ix_base < @SEQ; $ix_base++) {
						foreach $swap_base (keys %{$OTHER_BASES{$SEQ[$ix_base]}}) {
							@NEW = @SEQ;
							$NEW[$ix_base] = $swap_base;
							$new = join("", @NEW);
							if (!defined $HDSEQ_true{$new} && !defined $MODE_IXN_CHECK_true{$mode}{$index_number}{$new}) { # do not include if there is a lesser version
								$HDSEQ_true{$new} = $true;
								if (defined $opt{'V'}) {print STDERR "\t\tAdding HD = $new to True = $true.\n"};
							} elsif ($HDSEQ_true{$new} ne $true) {
								# equal collision
								if (defined $opt{'V'}) {print STDERR "\t\t\tTrue = $true, HD = $new, Equal HD collision = $HDSEQ_true{$new} - Excluding both.\n"};
								$HDSEQ_true{$new} = "collision";
							} else {
								# lesser collision
								if (defined $opt{'V'}) {print STDERR "\t\t\tTrue = $true, HD = $new, Lesser HD collision = $HDSEQ_true{$new} - Excluding new.\n"};
							}
						}
					}
				}
				# now load to the main hash & check they have not been observed with conflict
				foreach $seq (keys %HDSEQ_true) {
					if ($HDSEQ_true{$new} !~ /collision/) {
						$MODE_IXN_CHECK_true{$mode}{$index_number}{$seq} = $HDSEQ_true{$seq};
					}
				}
			}
		} else {
			if (defined $opt{'V'}) {print STDERR "\t\tIndex $index_number has a hamming of 0, so only exact matches will be considered.\n"};
		}
		
		if (defined $opt{'V'}) {
			%TRUE_count = ();
			foreach $seq (keys %{$MODE_IXN_CHECK_true{$mode}{$index_number}}) {
				$TRUE_count{$MODE_IXN_CHECK_true{$mode}{$index_number}{$seq}}++;
			}
			print STDERR "INFO: Mode: $mode, Index: $index_number, True sequences and HD assigned:\n";
			foreach $true (sort {$b<=>$a} keys %TRUE_count) {
				print STDERR "\t$true\t$TRUE_count{$true}\n";
			}
		}
	}
}

# set up output fastq files

system("mkdir $dex_path/$out_name");

foreach $mode (@MODES_LIST) {
	foreach $read_number (keys %{$DEX_PARTS{$mode}{'read'}}) {
		$handle = "$mode.R$read_number";
		open $handle, "| $gzip > $dex_path/$out_name/$out_name.$mode.R$read_number.fq.gz";
	}
}

# open input fastq files & output fail files

open R1IN, "$zcat $read1_fastq |"; open FAILR1, "| $gzip > $dex_path/$out_name/$out_name.fail.R1.fq.gz"; # read 1 is required
if ($read2_fastq ne "null") {open R2IN, "$zcat $read2_fastq |"; open FAILR2, "| $gzip > $dex_path/$out_name/$out_name.fail.R2.fq.gz"};
if ($index1_fastq ne "null") {open I1IN, "$zcat $index1_fastq |"; open FAILI1, "| $gzip > $dex_path/$out_name/$out_name.fail.I1.fq.gz"};
if ($index2_fastq ne "null") {open I2IN, "$zcat $index2_fastq |"; open FAILI2, "| $gzip > $dex_path/$out_name/$out_name.fail.I2.fq.gz"};

# read 1 = 1, index 1 = 2, index 2 = 3, read 2 = 4

if (defined $opt{'V'}) {print STDERR "INFO: Pulling reads and matching to indexes...\n"};

# parse fastq lines in order of listed modes
%MODE_assigned = (); $total_reads = 0;
while ($in_tag[1] = <R1IN>) {
	$total_reads++;
	# load in read from each file
	chomp $in_tag[1]; $in_seq[1] = <R1IN>; chomp $in_seq[1]; $null = <R1IN>; $in_qual[1] = <R1IN>; chomp $in_qual[1];
	if ($read2_fastq ne "null") {$in_tag[4] = <R2IN>; chomp $in_tag[4]; $in_seq[4] = <R2IN>; chomp $in_seq[4]; $null = <R2IN>; $in_qual[4] = <R2IN>; chomp $in_qual[4]};
	if ($index1_fastq ne "null") {$in_tag[2] = <I1IN>; chomp $in_tag[2]; $in_seq[2] = <I1IN>; chomp $in_seq[2]; $null = <I1IN>; $in_qual[2] = <I1IN>; chomp $in_qual[2]};
	if ($index2_fastq ne "null") {$in_tag[3] = <I2IN>; chomp $in_tag[3]; $in_seq[3] = <I2IN>; chomp $in_seq[3]; $null = <I2IN>; $in_qual[3] = <I2IN>; chomp $in_qual[3]};
	
	if (defined $opt{'V'}) {
		print STDERR "\tPulled Reads:\n";
		for ($vi = 1; $vi <= 4; $vi++) {
			if (defined $in_tag[$vi]) {print STDERR "\t\t$vi\t$in_tag[$vi]\t$in_seq[$vi]\t$in_qual[$vi]\n"};
		}
	}
	
	$read_passing = 0;
	
	# parse for each mode in order
	for ($modeID = 0; $modeID < @MODES_LIST; $modeID++) {
		$mode = $MODES_LIST[$modeID];
		
		if (defined $opt{'V'}) {print STDERR "\tParsing Mode: $mode, Index count for mode is $MODE_ixCT{$mode}\n"};
		
		$ix_pass = 0; $ix_fail = 0;
		$corrected_combined = "";
		for ($index_number = 1; $index_number <= $MODE_ixCT{$mode}; $index_number++) {
			$pulled_sequence = substr($in_seq[$DEX_PARTS{$mode}{'index'}{$index_number}[0]],
								$DEX_PARTS{$mode}{'index'}{$index_number}[1],
								$DEX_PARTS{$mode}{'index'}{$index_number}[2]);
			if (defined $opt{'V'}) {print STDERR "\t\tPulled Index Number $index_number = $pulled_sequence ... "};
			if (defined $MODE_IXN_CHECK_true{$mode}{$index_number}{$pulled_sequence}) {
				if (defined $opt{'V'}) {print STDERR "pass! Corrected index = $MODE_IXN_CHECK_true{$mode}{$index_number}{$pulled_sequence}\n"};
				$ix_pass++;
				$corrected_combined .= "$MODE_IXN_CHECK_true{$mode}{$index_number}{$pulled_sequence}";
			} else {
				if (defined $opt{'V'}) {print STDERR "failed, skipping read for $mode.\n"};
				$ix_fail++; $index_number = $MODE_ixCT{$mode}+1;
			}
		}
		if ($ix_fail < 1 && $ix_pass == $MODE_ixCT{$mode}) {
			$read_passing = 1;
			$MODE_assigned{$mode}++;
			# start compiling the read name
			$read_name = "\@$corrected_combined";
			# pull special fields
			if (defined $DEX_PARTS{$mode}{'other'}) {
				foreach $special_field (keys %{$DEX_PARTS{$mode}{'other'}}) {
					if ($DEX_PARTS{$mode}{'other'}{$special_field}[2] < 1) { # rest of read
						$pulled_sequence = substr($in_seq[$DEX_PARTS{$mode}{'other'}{$special_field}[0]],
												  $DEX_PARTS{$mode}{'other'}{$special_field}[1]);
					} else {
						$pulled_sequence = substr($in_seq[$DEX_PARTS{$mode}{'other'}{$special_field}[0]],
												  $DEX_PARTS{$mode}{'other'}{$special_field}[1],
												  $DEX_PARTS{$mode}{'other'}{$special_field}[2]);
					}
					$read_name .= ":$special_field=$pulled_sequence";
				}
			}
			# add origID & number
			$orig_name = $in_tag[1]; $orig_name =~ s/\#.+$//;
			$read_name .= ":num=$MODE_assigned{$mode}:tag=$orig_name";
			
			# pull reads $ quals then print
			foreach $read_number (keys %{$DEX_PARTS{$mode}{'read'}}) {
				if ($DEX_PARTS{$mode}{'read'}{$read_number}[2] < 1) { # rest of read from start position
					$pulled_sequence = substr($in_seq[$DEX_PARTS{$mode}{'read'}{$read_number}[0]],
											  $DEX_PARTS{$mode}{'read'}{$read_number}[1]);
					$pulled_qual = substr($in_qual[$DEX_PARTS{$read}{'read'}{$read_number}[0]],
										  $DEX_PARTS{$mode}{'read'}{$read_number}[1]);
				} else {
					$pulled_sequence = substr($in_seq[$DEX_PARTS{$mode}{'read'}{$read_number}[0]],
											  $DEX_PARTS{$mode}{'read'}{$read_number}[1],
											  $DEX_PARTS{$mode}{'read'}{$read_number}[2]);
					$pulled_qual = substr($in_qual[$DEX_PARTS{$mode}{'read'}{$read_number}[0]],
										  $DEX_PARTS{$mode}{'read'}{$read_number}[1],
										  $DEX_PARTS{$mode}{'read'}{$read_number}[2]);
				}
				$handle = "$mode.R$read_number";
				print $handle "$read_name#0/$read_number\n$pulled_sequence\n\+\n$pulled_qual\n";
			}
		}
	}
	
	# print failed reads
	if ($read_passing < 1) {
		$fail++;
		print FAILR1 "$in_tag[1]\n$in_seq[1]\n\+\n$in_qual[1]\n";
		if ($read2_fastq ne "null") {print FAILR2 "$in_tag[4]\n$in_seq[4]\n\+\n$in_qual[4]\n"};
		if ($index1_fastq ne "null") {print FAILI1 "$in_tag[2]\n$in_seq[2]\n\+\n$in_qual[2]\n"};
		if ($index2_fastq ne "null") {print FAILI2 "$in_tag[3]\n$in_seq[3]\n\+\n$in_qual[3]\n"};
	} else {
		$assigned++;
	}
}

# close files
close FAILR1;
if ($read2_fastq ne "null") {close FAILR2};
if ($index1_fastq ne "null") {close FAILI1};
if ($index2_fastq ne "null") {close FAILI2};

foreach $mode (@MODES_LIST) {
	foreach $read_number (keys %{$DEX_PARTS{$mode}{'read'}}) {
		$handle = "$mode.R$read_number";
		close $handle;
	}
}

# print report
open RPT, ">$dex_path/$out_name/$out_name.unidex.report.txt";
$pct = sprintf("%.2f", $assigned/$total_reads);
print RPT "Total Reads = $total_reads\nTotal Assigned = $assigned ($pct)\n";
foreach $mode (@MODES_LIST) {
	$pct = sprintf("%.2f", $MODE_assigned{$mode}/$assigned);
	print RPT "Mode $mode Assgined = $MODE_assigned{$mode} ($pct)\n";
}
close RPT;

exit;